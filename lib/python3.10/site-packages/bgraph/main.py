import argparse
import collections
import logging
import pathlib
import pickle
from enum import Enum
# import enum
from pathlib import Path
from typing import Dict, List, Set, Final, Sequence, Tuple

import re
import cmd2
import rich.console
import rich.filesize
import rich.table
import typer
from cmd2 import (Bg, Cmd2ArgumentParser, CompletionError, CompletionItem, Fg,
                  ansi, style, with_argparser)

class DependType(Enum):
    Up = 1
    Down = 2
    Both = 3

import networkx as nx  # type: ignore
import pygraphviz
from networkx.drawing.nx_agraph import graphviz_layout

import bgraph
import bgraph.exc
import bgraph.utils
from bgraph.types import (List, Optional, OutChoice, QueryType, Section, SectionNode, Union, all_module_types,
                          depends_on_impl, getSectionKey)

try:
    import matplotlib.pyplot as plt
except:
    raise 

logger: logging.Logger = bgraph.utils.create_logger(__name__)
"""Logger."""

def check_sections(up : SectionNode, down : SectionNode, dep_type : DependType) -> (bool, SectionNode, SectionNode):
    if dep_type is DependType.Up:
        return True, up, down
    elif dep_type is DependType.Down:
        return True, down, up
    else:
        return False, None, None


class SoongFile:

    def __init__(self, path : pathlib.Path = None):
        self.path : pathlib.Path = path
        self.section_nodes : Set[SectionNode] = set()

        self.up_soong_files : Set[SoongFile] = set()
        self.down_soong_files : Set[SoongFile] = set()

    def name(self) -> str:
        return str(self.path)

class Project:

    def __init__(self, path : pathlib.Path = None):
        self.path : pathlib.Path = path
        self.soong_files : Dict[pathlib.Path, List[SoongFile]] = collections.defaultdict(list)

        self.up_projects : Set[Project] = set()
        self.down_projects : Set[Project] = set()

    def hasSoongFile(self, file_path : pathlib.Path) -> bool:
        return bool(file_path in self.soong_files)

    def name(self) -> str:
        return str(self.path)

class GraphShell(cmd2.Cmd):

    pickle_file : Path = None

    CUSTOM_CATEGORY = 'My Custom Commands'

    def __init__(self):
        super().__init__(
            multiline_commands=['echo'],
            persistent_history_file='.gshell_history.dat',
            startup_script='scripts/startup.txt',
            include_ipy=True,
        )

        self.finished_set : Set[SectionNode] = set()
        self.query_dir_options = ['up', 'down', 'all']
        self.projects: Dict[pathlib.Path, Project] = collections.defaultdict(list)
        self.section_nodes : Set[SectionNode] = set()

        # Prints an intro banner once upon application startup
        self.intro = style('Welcome to gshell!', fg=Fg.RED, bg=Bg.WHITE, bold=True)

        # Show this as the prompt when asking for input
        self.prompt = 'gshell> '

        # Used as prompt for multiline commands after the first line
        self.continuation_prompt = '... '

        # Allow access to your application in py and ipy via self
        self.self_in_py = True

        # Set the default category name
        self.default_category = 'cmd2 Built-in Commands'

        # Color to output text in with echo command
        self.foreground_color = Fg.CYAN.name.lower()

        # Make echo_fg settable at runtime
        fg_colors = [c.name.lower() for c in Fg]
        self.add_settable(
            cmd2.Settable('foreground_color', str, 'Foreground color to use with echo command', self, choices=fg_colors)
        )

    @cmd2.with_category(CUSTOM_CATEGORY)
    def do_intro(self, _):
        """Display the intro banner"""
        self.poutput(self.intro)

    @cmd2.with_category(CUSTOM_CATEGORY)
    def do_echo(self, arg):
        """Example of a multiline command"""
        fg_color = Fg[self.foreground_color.upper()]
        self.poutput(style(arg, fg=fg_color))

    def generate_depend_edges(self,
                              down_node : SectionNode,
                              dep_type : DependType,
                              edges):
        for up_node in self.section_nodes:
            success, up, down = check_sections(up_node, down_node, dep_type)
            if success:
                success, dep_way = depends_on_impl(up, down)
                if success:
                    edges.append((up, down, {'label' : dep_way}))
                    down.up_level_nodes.add(up)
                    down.up_level_dep_ways[up] = dep_way
                    up.down_level_nodes.add(down)
                    up.down_level_dep_ways[down] = dep_way

    UNLIMITED_LEVELS : int = 1000000

    def build_section_graph(self,
                            max_levels : int,
                            down_node : SectionNode,
                            dep_type : DependType,
                            edges):
        if max_levels <= 0:
            logger.info("reached end of max_levels %d", max_levels)
        elif down_node in self.finished_set:
            logger.info("node %s already in finished set", down_node.name2())
        else:
            logger.info("with node:%s max_levels:%d", down_node.name2(), max_levels)
            self.finished_set.add(down_node)
            self.generate_depend_edges(down_node, dep_type, edges)

            down_project = self.projects[down_node.section['project_path']]
            if not isinstance(down_project, Project):
                raise LookupError

            down_soong_file = down_project.soong_files[down_node.section['soong_file_path']]
            if not isinstance(down_soong_file, SoongFile):
                raise LookupError

            for up_node in down_node.up_level_nodes.difference(self.finished_set):
                self.build_section_graph(max_levels - 1, up_node, dep_type, edges)

                up_project = self.projects[up_node.section['project_path']]
                if not isinstance(up_project, Project):
                    raise LookupError

                down_project.up_projects.add(up_project)
                up_project.down_projects.add(down_project)

                up_soong_file = up_project.soong_files[up_node.section['soong_file_path']]
                if not isinstance(up_soong_file, SoongFile):
                    raise LookupError

                down_soong_file.up_soong_files.add(up_soong_file)
                up_soong_file.down_soong_files.add(down_soong_file)


    SECTION_NODES_FILE_PATH = "/home/richard/section-nodes.pkl"

    # defaults_set : Set[SectionNode]
    def find_expand_defaults_node(self,
                                  node : SectionNode,
                                  section_name : str,
                                  defaults_set : Set[SectionNode]) -> SectionNode:
        result : Set[SectionNode] = set()
        for n in defaults_set:
            if n.section['section_name'] == section_name:
                if n == node:
                    raise LookupError
                if n not in node.merged_nodes:
                    result.add(n)
                else:
                    logger.info("already merged %s", section_name)
                    return None

        if len(result) == 1:
            return result.pop()
        elif len(result) > 1:
            for n in result:
                if node.section['soong_file_path'] == n.section['soong_file_path']:
                    logger.info("%d more than one, return the one in the same soong!", len(result))
                    return n
                elif node.section['project_path'] == n.section['project_path']:
                    logger.info("%d more than one, return one in the same project!", len(result))
                    return n

            logger.error("can only select first node!")
            return result.pop()
        else:
            logger.error("there is no defaults node with name %s", section_name)
            raise LookupError

    def dump_section(self, info : str, section : Section):
        if info == section['section_name']:
            logger.info("%s %s", info, section['section_name'])
            for key, value in section.items():
                logger.info("key:%s value:%s", key, repr(value))


    def merge_defaults_node(self, owner_node : SectionNode, defaults_node : SectionNode):
        for key, value in defaults_node.section.items():
            if key in [ 'section_name', 'section_type', 'project_path', 'soong_file_path', 'project_name' ]:
                pass
            elif key not in owner_node.section:
                if isinstance(value, list):
                    owner_node.section[key] = value.copy()
                else:
                    owner_node.section[key] = [ value ]
                logger.info("Merged defaults-node:%s, key:%s into owner node %s",
                            defaults_node.section['section_name'], key, owner_node.name2())
                self.dump_section("iorap-default-flags", defaults_node.section)
            elif not isinstance(owner_node.section[key], type(value)):
                if isinstance(owner_node.section[key], list):
                    owner_node.section[key].append(value)
                elif isinstance(value, list):
                    owner_node.section[key] = [ owner_node.section[key], *value.copy() ]
                    logger.info("after extend value of key %s, %s", key, repr(owner_node.section[key]))
                else:
                    raise LookupError
            elif isinstance(value, list):
                ext_list = [ v for v in value if v not in owner_node.section[key] ]
                if ext_list:
                    logger.info("Extend [%s]: %s with %s, for %s",
                                key, repr(owner_node.section[key]), repr(ext_list), owner_node.name2())
                    owner_node.section[key].extend(ext_list)
                else:
                    logger.info("empty ext_list! key:%s, node:%s, value:[%s] org-value:[%s]",
                                key, owner_node.name2(), repr(value), repr(owner_node.section[key]))
            elif owner_node.section[key] != value:
                logger.info("Overwrite [%s]: %s:%s to %s:%s", key, repr(owner_node.section[key]), type(owner_node.section[key]), repr(value), type(value))
                owner_node.section[key] = value
        owner_node.merged_nodes.add(defaults_node)


    def try_expand_defaults(self, node : SectionNode, defaults_set : Set[SectionNode]):
        while 'defaults' in node.section:
            defaults = node.section['defaults']
            del node.section['defaults']

            logger.info("before expand:%s, DEFAULTS:%s", repr(node.section), repr(defaults))
            if isinstance(defaults, str):
                logger.info("--> %s got a default name: %s", node.name2(), defaults)
                n = self.find_expand_defaults_node(node, defaults, defaults_set)
                if n:
                    # logger.info("<< find_expand_defaults_node %s [%s] got [%s]", node.name2(), defaults, n.name2())
                    self.merge_defaults_node(node, n)
            elif isinstance(defaults, list):
                for name in defaults:
                    # logger.info("%s got a defaults list: %s, name:%s", node.name2(), repr(defaults), name)
                    n = self.find_expand_defaults_node(node, name, defaults_set)
                    if n:
                        self.merge_defaults_node(node, n)
            else:
                raise LookupError

            if 'defaults' in node.section:
                defaults = node.section['defaults']
                logger.info("%s after DEFAULTS:%s", node.name2(), repr(defaults))


        logger.info("After expand:%s", repr(node.section))

    def expand_default_sections(self):
        defaults_set = set()
        defaults_types = [ t for t in all_module_types if re.search("^\w+_defaults\Z", t) ]
        logger.info("defaults_types:%s", repr(defaults_types))
        for node in self.section_nodes:
            if node.section['section_type'] in defaults_types:
                defaults_set.add(node)
                logger.info("got a defaults:%s", node.name2())

        # self.check_duplicated_name_sections(defaults_set)

        for n in self.section_nodes.difference(defaults_set):
            self.try_expand_defaults(n, defaults_set)


    def check_duplicated_name_sections(self, nodes : Set[SectionNode]):
        sections : Dict[str, Set[SectionNode]] = {}
        for node in nodes:
            name = node.section['section_name']
            if not sections.get(name):
                sections[name] = { node }
            elif not isinstance(sections[name], set):
                raise LookupError
            elif node in sections[name]:
                logger.error("node %s already in sections", node.name2())
                raise LookupError
            else:
                sections[name].add(node)

        uniq_cc = 0
        multi_cc = 0
        for name, nodes in sections.items():
            if len(nodes) ==  1:
                uniq_cc = uniq_cc + 1
            else:
                multi_cc = multi_cc + 1
                names = [ n.name2() for n in nodes ]
                logger.info("[%s]:", name)
                for s in names:
                    logger.info("\t[%s]", s)                    
                logger.info("\n")
                
        logger.info("got uniq:%d, multi:%d", uniq_cc, multi_cc)

        
    def do_check_duplicated_name_sections(self, _ : argparse.Namespace):
        self.check_duplicated_name_sections(self.section_nodes)


    def do_expand_sections(self, _ : argparse.Namespace):
        self.expand_default_sections()
    
    def do_gen_nodes_graph(self, _ : argparse.Namespace):
        self.finished_set.clear()
        for node in self.section_nodes:
            edges : List[(SectionNode, SectionNode, {})] = []
            self.build_section_graph(self.UNLIMITED_LEVELS, node, DependType.Up, edges)

        try:
            with open(self.SECTION_NODES_FILE_PATH, "wb") as file:
                pickle.dump(self.section_nodes, file)
        except pickle.PickleError:
            logger.error("Failed to pickle dump section nodes to file %s", self.SECTION_NODES_FILE_PATH)

    def load_nodes_graph(self):
        with open(self.SECTION_NODES_FILE_PATH, "rb") as file:
            section_nodes = pickle.load(file)
            self.init_section_nodes(section_nodes)

    def do_load_nodes_graph(self, _ : argparse.Namespace):
        self.load_nodes_graph()

    dump_parser = Cmd2ArgumentParser(description="dump section nodes")
    dump_parser.add_argument('-l', '--max_levels', type=int, default=1, help='1 means only dump the leaf node')
    dump_parser.add_argument('-a', '--all', action='store_true', help='dump all nodes')

    def dump_types_provider(self) -> List[str]:
        return [ self.PROJECT, self.SOONG_FILE, self.SECTION, self.CHECK_CIRCULAR_DEP, self.ALL_MODULE_TYPES ]

    dump_parser.add_argument(
        "--type",
        choices_provider=dump_types_provider,
        metavar="TYPE",
        help="dump node types"
    )


    def dump_module_types_provider(self) -> List[str]:
        return all_module_types

    dump_parser.add_argument(
        "--module_type",
        choices_provider=dump_module_types_provider,
        metavar="MODTYPE",
        help="dump node with specified module type"
    )

    def dump_up_node_graph(self,
                           root : SectionNode,
                           levels : int,
                           max_levels : int) -> None:
        if levels < max_levels:
            if levels == 0:
                logger.info("root-up-node: %s", root.name2())

            tab = '--'
            levels = levels + 1
            for node in root.up_level_nodes:
                logger.info("%d %s: %s", levels, ''.join([c * levels for c in tab]), node.name2())
                self.dump_up_node_graph(node, levels, max_levels)

    def dump_down_node_graph(self,
                             root : SectionNode,
                             levels : int,
                             max_levels : int) -> None:
        if levels < max_levels:
            if levels == 0:
                logger.info("root-node: %s", root.name2())

            tab = '--'
            levels = levels + 1
            for node in root.down_level_nodes:
                logger.info("%d %s: %s", levels, ''.join([c * levels for c in tab]), node.name2())
                self.dump_down_node_graph(node, levels, max_levels)

    def dump_project_graph(self, project : Project, levels : int, max_levels : int) -> None:
        if levels < max_levels:
            if levels == 0:
                logger.info("root-project: %s", project.name())

            tab = '    '
            levels = levels + 1
            for down_pj in project.down_projects:
                logger.info("%d %s |---: %s", levels, ''.join([c * levels for c in tab]), down_pj.name())
                self.dump_project_graph(down_pj, levels, max_levels)

    def dump_soong_file_graph(self, soong_file : SoongFile, levels : int, max_levels : int) -> None:
        if levels < max_levels:
            if levels == 0:
                logger.info("root-soong: %s", soong_file.name())
            tab = '    '
            levels = levels + 1
            for down_soong in soong_file.down_soong_files:
                logger.info("%d %s |---: %s", levels, ''.join([c * levels for c in tab]), down_soong.name())
                self.dump_soong_file_graph(down_soong, levels, max_levels)

    def check_if_circular_depended(self,
                                   node : SectionNode,
                                   down_node : SectionNode,
                                   passed_nodes : List[Tuple[SectionNode, str]],
                                   circular_nodes : Set[SectionNode]) -> bool:
        if node in circular_nodes:
            logger.info("=== Old Circular Node:%s", node.name2())
            return True
        elif node in [ n for (n, _) in passed_nodes ]:
            logger.info("\n")
            for (n, dep_way) in passed_nodes:
                logger.info("In List:%s, dep:%s", n.name2(), dep_way)
            if down_node:
                logger.info("=== Target Circular Node:%s dep-way:%s", node.name2(), down_node.up_level_dep_ways[node])
            else:
                logger.info("=== Target Circular Node:%s dep-way:None", node.name2())
            circular_nodes.add(node)
            return True
        else:
            if down_node:
                passed_nodes.append((node, down_node.up_level_dep_ways[node]))
            else:
                passed_nodes.append((node, "None"))
            for n in node.up_level_nodes:
                if self.check_if_circular_depended(n, node, passed_nodes.copy(), circular_nodes):
                    return True

            return False

    def check_if_any_circular_depended(self, nodes : Set[SectionNode]):
        circular_nodes = set()
        for i, n in enumerate(nodes):
            if self.check_if_circular_depended(n, None, [], circular_nodes):
                logger.info("%d got circular dep node %s", i, n.name2())

        logger.info("there are %d circular dep nodes in these %d nodes", len(circular_nodes), len(nodes))

        for i, node in enumerate(circular_nodes):
            logger.info("%d circular node %s", i, node.name2())
            

    def dump_node_graph_with_level(self,
                                   levels : int,
                                   max_levels : int,
                                   undumped_nodes : Set[SectionNode],
                                   dumped_nodes : Set[SectionNode]) -> None:
        if levels < max_levels:
            if not undumped_nodes:
                logger.info("REACHED THE END WITH LEVELS %d", levels)
            else:
                tab = '--'
                once_dumped_nodes : Set[SectionNode] = set()
                for node in undumped_nodes:
                    valid_up_level_nodes = node.up_level_nodes.difference(dumped_nodes)
                    if not valid_up_level_nodes:
                        once_dumped_nodes.add(node)
                        dumped_cc = len(dumped_nodes) + len(once_dumped_nodes)
                        logger.info("levels:%d dumped:%d %s:%s", levels, dumped_cc, ''.join([c * levels for c in tab]), node.name2())
                dumped_nodes.update(once_dumped_nodes)
                undumped_nodes = undumped_nodes.difference(dumped_nodes)
                self.dump_node_graph_with_level(levels + 1, max_levels, undumped_nodes, dumped_nodes)
        else:
            logger.info("REACHED THE MAX LEVEL %d %d", levels, max_levels)

    def dump_all_module_types(self):
        module_types : Dict[str, int] = {}
        for node in self.section_nodes:
            st = node.section['section_type']
            if st in module_types:
                module_types[st] = module_types[st] + 1
            else:
                module_types[st] = 1

        index = 0
        module_types = dict(sorted(module_types.items(), key=lambda x:x[1]))
        with open("/home/richard/all-module-types.txt", "w") as file:
            file.write("[ ")
            for key, val in module_types.items():
                logger.info("%d type: [%s, %d]", index, key, val)
                index = index + 1
                file.write("\"%s\", " % key)
            file.write(" ]")


    @with_argparser(dump_parser)
    def do_dump(self, args : argparse.Namespace):
        total_nodes = set()
        if not args.module_type:
            total_nodes = self.section_nodes
        else:
            for node in self.section_nodes:
                if node.section['section_type'] == args.module_type:
                    total_nodes.add(node)
                    logger.info("%d added node:[%s] with type:[%s] into total set", len(total_nodes), node.name2(), args.module_type)

        if args.type == self.ALL_MODULE_TYPES:
            self.dump_all_module_types()
        elif args.type == self.CHECK_CIRCULAR_DEP:
            self.check_if_any_circular_depended(total_nodes)
        elif args.type == self.SECTION:
            if args.all:
                self.dump_node_graph_with_level(0, args.max_levels, total_nodes, set())
            else:
                for node in total_nodes:
                    if not node.up_level_nodes: # start from leaf node
                        self.dump_down_node_graph(node, 0, args.max_levels)
        elif args.type == self.PROJECT:
            logger.info("dump project")
            for project in self.projects.values():
                if not project.up_projects:
                    self.dump_project_graph(project, 0, args.max_levels)
        elif args.type == self.SOONG_FILE:
            logger.info("dump soong file")
            for project in self.projects.values():
                for soong_file in project.soong_files.values():
                    if not soong_file.up_soong_files:
                        self.dump_soong_file_graph(soong_file, 0, args.max_levels)
        else:
            raise LookupError("invalid args type")


    def gen_section_up_graph(self, down_node : SectionNode, max_levels : int):
        graph = nx.DiGraph()
        # graph = nx.complete_graph(3, create_using=nx.DiGraph)
        # graph = nx.balanced_tree(r=5, h=6, create_using=nx.DiGraph)

        self.finished_set.clear()
        edges : List[(SectionNode, SectionNode, {})] = []

        logger.info(">> build_section_graph")
        self.build_section_graph(max_levels, down_node, DependType.Up, edges)
        logger.info("<< build_section_graph %d:%s", len(edges), repr(edges))

        graph.add_node(down_node, label=down_node.name())

        for up_node, down_node, label in edges:
            graph.add_node(up_node, label=up_node.name())
            # graph.add_node(up_node, label=getSectionKey(up_node.section))
            # graph.add_node(down_node, label=getSectionKey(down_node.section))

        graph.add_edges_from(edges)


        logger.info(">> graphviz_layout")
        # pos = graphviz_layout(graph, prog="twopi")
        pos = graphviz_layout(graph, prog="neato")
        # pos = graphviz_layout(graph, prog="dot")
        # pos = graphviz_layout(graph, prog="circo")
        logger.info(">> draw")
        # nx.draw_networkx_edge_labels(graph, pos)

        nx.draw_networkx_nodes(graph, pos, node_size=50, node_color='g', alpha = 0.1)  # draws nodes
        nx.draw_networkx_edges(graph, pos, width=2.0, edge_color='r', alpha = 0.6)  # draws edges
        nx.draw_networkx_edge_labels(graph, pos, edge_labels=nx.get_edge_attributes(graph, 'label')) # edge lables
        nx.draw_networkx_labels(graph, pos, labels=nx.get_node_attributes(graph, 'label')) # node lables

        # nx.draw(graph, pos, node_size=50, with_labels=True)

        logger.info("%s", f">> save {down_node.section['section_name']}.png")
        plt.savefig(f'{down_node.section["section_name"]}.png') # save as png
        plt.box(False) # no frame around it
        plt.show() # display

        logger.info("%s", f">> write_network_text {down_node.section['section_name']}.nwk")
        # nx.write_network_text(graph, path=f'{section["section_name"]}.nwk', with_labels='label', max_depth=20, ascii_only=True, sources = [ getSectionKey(section) ])
        nx.write_network_text(graph, path=f'{down_node.section["section_name"]}.nwk', with_labels=True, ascii_only=True)

    def init_section_nodes(self, sections : Sequence[Section]) -> None:

        self.projects.clear()
        self.section_nodes.clear()

        for section in sections:
            self.section_nodes.add(SectionNode(section))

        for node in self.section_nodes:
            project_path = node.section['project_path']
            soong_file_path = node.section['soong_file_path']
            if not isinstance(project_path, pathlib.Path) or not isinstance(soong_file_path, pathlib.Path):
                logger.info("project or soong is not a path")
            else:
                project = self.projects[project_path]
                if not isinstance(project, Project): # no project
                    project = Project(project_path)
                    self.projects[project_path] = project

                soong_file = project.soong_files[soong_file_path]
                if not isinstance(soong_file, SoongFile): # no soong file
                    soong_file = SoongFile(soong_file_path)
                    project.soong_files[soong_file_path] = soong_file

                if not node in soong_file.section_nodes: # no section
                    soong_file.section_nodes.add(node)

        for project_path, project in self.projects.items():
            logger.info("\t project:%s", project.path)
            for soong_file in project.soong_files.values():
                logger.info("\t\t soong file:%s", soong_file.path)
                for node in soong_file.section_nodes:
                    logger.info("\t\t\t section:%s/%s", node.section['section_name'], node.section['section_type'])

        logger.info("TOTALLY THERE ARE %d PROJECTS, %d SOONG FILES, %d SECTION NODES",
                    len(self.projects), sum(len(proj.soong_files.values()) for proj in self.projects.values()), len(self.section_nodes))

    def dir_provider(self) -> List[str]:
        """A choices provider is useful when the choice list is based on instance data of your application"""
        return self.query_dir_options

    # Parser for example command
    query_parser = Cmd2ArgumentParser(description="query section deps of a soong file of a project, with direct")

    # # Tab complete from choices provided by a choices_provider
    # query_parser.add_argument(
    #     "direct",
    #     choices_provider=dir_provider,
    #     metavar="DIR",
    #     help="tab complete using a choices_provider"
    # )

    PROJECT : str = "project"
    SOONG_FILE : str = "soong_file"
    SECTION : str = "section"
    NODE : str = "node"
    ALL_MODULE_TYPES : str = "all_module_types"
    CHECK_CIRCULAR_DEP : str = "check_circular_dep"

    """Type of the section (e.g. cc_library)."""

    def project_provider(self) -> List[str]:
        """A choices provider is useful when the choice list is based on instance data of your application"""
        return [ str(project.path) for project in self.projects.values() ]

    def soong_file_provider(self, arg_tokens: Dict[str, List[str]]) -> List[str]:
        """
        a particular argument expects only 1 token.
        """
        if self.PROJECT in arg_tokens:
            project_path = pathlib.Path(arg_tokens[self.PROJECT][0])
            project = self.projects[project_path]
            return [ str(f.path) for f in project.soong_files.values() ]
        else:
            logger.error("arg_tokens contains no %s", self.PROJECT)
            return list(map(lambda project : [ str(file.path) for file in project.soong_files.values() ],
                            self.projects.values()))

    def section_provider(self, arg_tokens: Dict[str, List[str]]) -> List[str]:
        """
        a particular argument expects only 1 token.
        """
        if self.SOONG_FILE in arg_tokens:
            soong_path = pathlib.Path(arg_tokens[self.SOONG_FILE][0])
            for project in self.projects.values():
                for soong_file in project.soong_files.values():
                    if soong_file.path == soong_path:
                        return [ node.section['section_name'] for node in soong_file.section_nodes ]

            return []
        else:
            logger.error("arg_tokens contains no %s, arg_tokens:%s", self.SOONG_FILE, repr(arg_tokens))
            return [ sec['section_name'] for sec in self.section_nodes ]

    query_parser.add_argument('-u', '--up',
                              action='store_true',
                              help='list who depends on the specified scopes including project, Android.bp and target')
    query_parser.add_argument('-d', '--down',
                              action='store_true',
                              help='list targets on which the specified module depends')
    query_parser.add_argument('-a', '--all',
                              action='store_true',
                              help='list all dependencies including both the up and down')

    query_parser.add_argument(
        f"--{PROJECT}",
        choices_provider=project_provider,
        metavar="PROJECT",
        help="tab complete using a choices_provider"
    )

    query_parser.add_argument(
        f"--{SOONG_FILE}",
        choices_provider=soong_file_provider,
        metavar="SOONG",
        help="tab complete using a choices_provider"
    )

    query_parser.add_argument(
        f"--{SECTION}",
        choices_provider=section_provider,
        metavar="SECTION",
        help="specify the section with a name"
    )

    query_parser.add_argument('-l', '--max_levels', type=int, default=2, help='output [n] times')

    def find_section_node(self, project_path : Path, soong_file_path : Path, section_name : str) -> (SectionNode | Set[SectionNode] | None):
        project = None
        if project_path is not None:
            project = self.projects[project_path]

        if project is not None:
            soong_file = project.soong_files[soong_file_path]
            if soong_file is not None:
                for node in soong_file.section_nodes:
                    if node.section["section_name"] == section_name:
                        return node
                    else:
                        pass
            else:
                logger.error("sections is None with soong file path %s", repr(soong_file_path))

            logger.error("return None with %s %s %s", repr(project_path), repr(soong_file_path), section_name)
            return None
        else:
            result : Set[SectionNode] = set()
            for node in self.section_nodes:
                if node.section['section_name'] == section_name:
                    result.add(node)
            if len(result) == 1:
                return result.pop()
            elif len(result) > 1:
                return result
            else:
                return None

    @with_argparser(query_parser)
    def do_query(self, args: argparse.Namespace):
        """Repeats what you tell me to."""
        if args.project is None:
            logger.error("please specify the project!")
        elif args.soong_file is None:
            logger.error("please specify the soong file path!")
        elif args.section is None:
            logger.error("please specify the section!")
        else:
            logger.info("got project:%s soong:%s section:%s", args.project, args.soong_file, args.section)
            node = self.find_section_node(Path(args.project), Path(args.soong_file), args.section)
            if node is None:
                logger.error("find no node!")
            else:
                logger.info("gen_section_up_graph:[%s] max_levels:%d", node.name2(), args.max_levels)
                for n in node.up_level_nodes:
                    logger.info("---- up %s", n.name2())
                for n in node.down_level_nodes:
                    logger.info("---- down %s", n.name2())
                self.gen_section_up_graph(node, args.max_levels)


    argparser = Cmd2ArgumentParser()
    argparser.add_argument('-p', '--piglatin', action='store_true', help='atinLay')
    argparser.add_argument('-s', '--shout', action='store_true', help='N00B EMULATION MODE')
    argparser.add_argument('-r', '--repeat', type=int, help='output [n] times')
    # argparser.add_argument('word', nargs='?', help='word to say')

    @with_argparser(argparser)
    def do_speak(self, opts):
        """Repeats what you tell me to."""
        arg = opts.word
        if opts.piglatin:
            arg = '%s%say' % (arg[1:], arg[0])
        if opts.shout:
            arg = arg.upper()
        repetitions = opts.repeat or 1
        for i in range(min(repetitions, 20)):
            self.poutput(arg)

    def set_pick_file(self, pickle_file : Path):
        self.pickle_file = pickle_file

    def do_exit(self, inp):
        print("Bye")
        return True

    def help_exit(self):
        print("exit the application. Shorthand: x q Ctrl-D.'")

    def do_add(self, inp):
        print(f"adding '{inp}'")

    def help_add(self):
        print("Add a new entry to the system.")

    def default(self, line):
        if line == 'x' or line == 'q':
            return self.do_exit(line)
 
        print("Default: {}".format(line))
 
    do_EOF = do_exit
    help_EOF = help_exit

app = typer.Typer()

@app.command(name="generate-single")
def generate_single(
    result_dir: Path = typer.Argument(
        ...,
        help="Where to store the result",
        dir_okay=True,
        exists=True,
        writable=True,
        resolve_path=True,
    ),
    branch_name: str = typer.Argument(
        ..., help="Branch from which generating the BGraph"
    ),
    mirror: str = typer.Argument(
        ...,
        help="Mirror directory for AOSP (either a link or a path)",
    ),
    workdir: Optional[Path] = typer.Option(
        None, help="Workdir", dir_okay=True, writable=True, exists=True
    ),
):
    """Generate a BGraph from a branch.

    It will work in the workdir and store results in result_dir.
    """

    # Assume the mirror is a Path if "http" is not found in mirror.
    mirror_path: Union[str, pathlib.Path] = bgraph.utils.clean_mirror_path(mirror)

    workdir = bgraph.builder.compose_local_manifest_branch(mirror_path, workdir)

    if workdir is None:
        typer.echo("Compose manifest failed.", err=True)
        raise typer.Exit(code=1)

    bgraph.builder.convert(workdir, result_dir)

gshell = GraphShell()

@app.command(name="load-pickle")
def load_pickle(
    file_path: Path = typer.Argument(
        ...,
        help="Where to load the pickle file",
        exists=True,
    ),
):
    """test load pickle file soong parser from a pickle file.
    """

    print("file_path is " + repr(file_path))

    with open(file_path, "rb") as file:
        soong_parser = pickle.load(file)

    print("sections len ", len(soong_parser.sections))
    print("section_nodes len ", len(soong_parser.section_nodes))

    # for section in soong_parser.section_nodes:
    #     print("\nsection: " + getSectionKey(section))
    #     for key in section:
    #         print(key + ":" + repr(section[key]))

    import sys
    gshell.init_section_nodes(soong_parser.sections.values())
    sys.exit(gshell.cmdloop())


@app.command()
def generate(
    result_dir: Path = typer.Argument(
        ...,
        dir_okay=True,
        exists=True,
        writable=True,
        resolve_path=True,
        help="Where to store the resulting BGraph",
    ),
    mirror: str = typer.Argument(
        ..., help="Path to the mirror or the URL to AOSP source"
    ),
    branch_pattern: str = typer.Option(
        "android-*", help="Pattern to match the branches"
    ),
    workdir: Optional[Path] = typer.Option(
        None, help="Work directory (default will be a tmp directory)"
    ),
):
    """Generate BGraph's from a mirror dir."""

    mirror_path: Union[str, pathlib.Path] = bgraph.utils.clean_mirror_path(mirror)

    workdir = bgraph.builder.compose_all(mirror_path, branch_pattern, workdir)

    bgraph.builder.convert(workdir, result_dir)
    founds = len(list(result_dir.glob("*.bgraph")))
    typer.echo(f"Generated {founds} graphs.")


@app.command(name="list")
def list_command(
    directory: Path = typer.Argument(
        None,
        file_okay=False,
        dir_okay=True,
        exists=True,
        readable=True,
        resolve_path=True,
        help="The directory to search BGraph files",
    ),
    extension: Optional[str] = typer.Option(
        ".bgraph", help="Extension of the BGraph files"
    ),
):
    """
    List the BGraph already generated.
    """

    table = rich.table.Table(title="BGraph founds :")
    table.add_column("Name", justify="right")
    table.add_column("Size", justify="right")

    for bgraph_file in directory.rglob(f"*{extension}"):

        table.add_row(
            bgraph_file.name, rich.filesize.decimal(bgraph_file.stat().st_size)
        )

    console = rich.console.Console()
    console.print(table)


@app.command()
def query(
    graph_path: Path = typer.Argument(
        ...,
        file_okay=True,
        dir_okay=False,
        exists=True,
        resolve_path=True,
        readable=True,
        help="BGraph to query",
    ),
    target: str = typer.Option(None, help="Target to query"),
    src: str = typer.Option(None, help="Source file"),
    dependency: str = typer.Option(None, "--dep", help="Dependecy"),
    out: OutChoice = typer.Option(OutChoice.TXT, help="Output format"),
):
    """Query a BGraph."""

    defined = [target is not None, src is not None, dependency is not None]
    if defined.count(True) > 1:
        typer.echo("Define only one of src/target/dependency")
        raise typer.Exit(code=1)

    try:
        graph = bgraph.viewer.load_graph(graph_path)
    except bgraph.exc.BGraphLoadingException:
        typer.echo("Unable to load the graph")
        raise typer.Exit(code=1)

    result: List[str]
    query_type: QueryType
    if target is not None:
        result = bgraph.viewer.find_sources(graph, target)
        query_type = QueryType.TARGET
        query_value = target
    elif src is not None:
        query_value, result = bgraph.viewer.find_target(graph, src)
        query_type = QueryType.SOURCE
    else:
        query_type = QueryType.DEPENDENCY
        result = bgraph.viewer.find_dependency(graph, dependency)
        query_value = dependency

    if not result:
        typer.echo("No result for request")
        raise typer.Exit(code=2)

    bgraph.viewer.format_result(graph, result, query_type, query_value, out)


@app.callback()
def main(
    verbose: bool = typer.Option(
        False, "--verbose", "-v", help="Activate verbose output"
    )
):
    """BGraph - generate and query build dependency graphes.

    BGraph is used to manipulate build dependency graphs generated from blueprint files.
    The main commands are:

        - generate : used to generates multiples graphs

        - query: used to query a previously generated graph

    To get more help, see the online documentation.
    """
    import sys
    logger.info("getrecursionlimit %d", sys.getrecursionlimit())
    sys.setrecursionlimit(20000)

    import logging
    logging.basicConfig(filename='gshell.log', encoding='utf-8', filemode='w', level=logging.DEBUG)

    gshell.debug = True

    logging_level = logging.INFO
    if verbose:
        logging_level = logging.DEBUG

    logging.getLogger().setLevel(logging_level)
