import enum
import logging
import re
import sys
import pathlib
from typing import (Any, Callable, Dict, Final, Generator, Iterable, List,
                    Literal, Optional, Set, Tuple, TypedDict, Union, cast,
                    overload)


class OutChoice(str, enum.Enum):
    """Output format choices"""

    TXT: str = "text"
    JSON: str = "json"
    DOT: str = "dot"

class QueryType(str, enum.Enum):
    """Possible query types"""

    SOURCE: str = "source"
    TARGET: str = "target"
    DEPENDENCY: str = "dependency"

NodeType = str
"""Type of a node."""

ResultDict = TypedDict(
    "ResultDict", {"sources": List[str], "target": List[Tuple[str, str]]}, total=False
)
"""Type of a result dict (used in formatter)."""


# TODO(dm): Wait until TypedDict accept Final as keys to rewrite this
class Section(TypedDict, total=False):
    section_type: str
    section_name: str
    project_name : str
    project_path : pathlib.Path
    soong_file_path : pathlib.Path

    # Some value names from Soong
    defaults: Union[str, List[str]]

def getSectionKey(section : Section) -> str:
    return section["section_name"] + "\n" + section["section_type"] + "\n" + str(section["soong_file_path"])

def getSectionName(section : Section) -> str:
    return section["section_type"] + " " + str(section["soong_file_path"]) + " " + section["section_name"]

class SectionNode:

    def __init__(self, section : Section = None):
        self.section = section
        self.up_level_nodes : Set[SectionNode] = set()
        self.up_level_dep_ways : Dict[SectionNode, str] = {}
        self.down_level_nodes : Set[(SectionNode, str)] = set()
        self.down_level_dep_ways : Dict[SectionNode, str] = {}
        self.defaults_nodes : Set[Tuple[SectionNode, int]] = set()

    def is_node_in_defaults(self, node) -> bool:
        for (n, _) in self.defaults_nodes:
            if n == node:
                return True
        return False

    def __key(self):
        if self.section:
            return (self.section['soong_file_path'], self.section['section_type'], self.section['section_name'])
        else:
            raise LookupError

    def __hash__(self):
        return hash(self.__key())

    def __eq__(self, other):
        if isinstance(other, SectionNode):
            return self.__key() == other.__key()
        else:
            raise LookupError

    def name(self):
        return getSectionKey(self.section)

    def name2(self):
        return getSectionName(self.section)

excluded_sub_types = ("section_name", "section_type", "project_name", "project_path",
                      "export_include_dirs", "stem", "pkg_path", "relative_install_path")
excluded_section_types = []
COLON_PREFIX_ENABLED_SUB_TYPES = ("certificate", "srcs")

def is_defaults_module(node : SectionNode) -> bool:
    return re.search(r"^\w+_defaults\Z", node.section['section_type'])

SUPPORTED_TARGET_ARCHS = [ 'arm' ]

def has_invalid_target_arch(section : Section) -> bool:
    target_arch = 'target_arch'
    if target_arch not in section:
        return False
    elif section[target_arch] in SUPPORTED_TARGET_ARCHS:
        return False
    else:
        return True


def check_target_matching(l : SectionNode, r : SectionNode) -> bool:
    target_arch = 'target_arch'
    if target_arch in l.section and target_arch in r.section:
        return l.section[target_arch] == r.section[target_arch]
    elif target_arch not in l.section and target_arch not in r.section:
        return True
    elif target_arch in l.section and target_arch not in r.section:
        return l.section[target_arch] in SUPPORTED_TARGET_ARCHS
    elif target_arch not in l.section and target_arch in r.section:
        return r.section[target_arch] in SUPPORTED_TARGET_ARCHS
    else:
        raise LookupError

HOST_SUPPORTED_SECTION_TYPES = ("java_plugin", "blueprint_go_binary", "blueprint_go_package") 

def check_host_supported(section : Section) -> (bool, bool):
    if 'host_supported' in section:
        if section['host_supported'] is True:
            return True, True
        else:
            return False, False
    elif section['section_type'] in HOST_SUPPORTED_SECTION_TYPES:
        return True, False
    elif re.search(r"_host", section['section_type']):
        return True, False
    elif re.search(r"^\w+_go_\w+\Z", section['section_type']):
        return True, False
    else:
        return False, False

DOWN_HOST_SUPPORTED_SUB_TYPES = ("prebuilt_apex", "filegroup")

def check_host_supported_matching(up : SectionNode, down : SectionNode) -> bool:
    up_host_support, up_both_support = check_host_supported(up.section)
    down_host_support, down_both_support = check_host_supported(down.section)
    if up_both_support or down_both_support:
        return True
    elif up_host_support == down_host_support:
        return True
    elif down.section['section_type'] in DOWN_HOST_SUPPORTED_SUB_TYPES:
        return True
    else:
        return False

def check_if_cc_bin_unmatching(up : SectionNode, down : SectionNode) -> bool:
    if (re.search(r"^cc_\w+", up.section['section_type']) and
        re.search(r"^vndk_prebuilt_\w+", down.section['section_type'])):
        return True
    elif (re.search(r"^cc_\w+", down.section['section_type']) and
        re.search(r"^vndk_prebuilt_\w+", up.section['section_type'])):
        return True
    else:
        return False

def is_ndk_enabled_section(section : Section) -> bool:
    if ('backend' in section and
        isinstance(section['backend'], dict) and
        'ndk' in section['backend'] and
        isinstance(section['backend']['ndk'], dict) and
        'enabled' in section['backend']['ndk'] and
        isinstance(section['backend']['ndk']['enabled'], bool)):
        return section['backend']['ndk']['enabled']
    else:
        return False


def has_backend_dict(section : Section) -> bool:
    return 'backend' in section and isinstance(section['backend'], dict)

def has_backend_dict_with_subtype(section : Section, sub_type : str) -> bool:
    return (has_backend_dict(section) and
            sub_type in section['backend'] and
            isinstance(section['backend'][sub_type], dict))


def has_backend_dict_with_subtype_enabled(section : Section, sub_type : str) -> bool:
    if (has_backend_dict(section) and
        sub_type in section['backend'] and
        isinstance(section['backend'][sub_type], dict)):
        sub = section['backend'][sub_type]
        if 'enabled' in sub and isinstance(sub['enabled'], bool):
            return sub['enabled']
        else:
            return True         # default enabled
    else:
        return False

def get_backend_suffixed_names(section : Section) -> List[str]:
    suffixes = ("-cpp", "-java", "-ndk")
    suffixed_names = []
    for s in suffixes:
        if has_backend_dict_with_subtype_enabled(section, s[1:]):
            if s == "-ndk":
                suffixed_names.append(section['section_name'] + "-ndk_platform")
            else:
                suffixed_names.append(section['section_name'] + s)
    return suffixed_names

DEBUG_UP_NODE_NAMES = [ "vts_vndk_utils", "merge_zips" ]
DEBUG_DOWN_NODE_NAMES = [ "vndk_lib_lists", "soong_zip" ]

def check_if_debug_nodes(up : SectionNode, down : SectionNode) -> bool:
    return (up.section['section_name'] in DEBUG_UP_NODE_NAMES and
            down.section['section_name'] in DEBUG_DOWN_NODE_NAMES)

def check_if_plugin_for_dep(up : SectionNode, down : SectionNode) -> (bool, str):
    return check_if_subtype_matching(up, down, 'pluginFor')

def check_up_genrule_depends(up : SectionNode, down : SectionNode) -> (bool, bool, str):
    if not re.search(r"genrule\Z", up.section['section_type']):
        return False, False, None # not a genrule
    else:
        sub_types = [ "srcs", "tools", "tool_files" ]
        for sub in sub_types:
            if sub in up.section:
                values = up.section[sub] if isinstance(up.section[sub], list) else [ up.section[sub] ]
                for name in values:
                    if (re.search(r"^:\w+", name) and
                        down.section['section_name'] == name[1:]):
                        return True, True, sub
                    elif down.section['section_name'] == name:
                        return True, True, sub

        return True, False, None


def setup_up_down_dependency(up : SectionNode,
                             down : SectionNode,
                             dep_way : str,
                             edges : List[Tuple[SectionNode, SectionNode, Dict[str, any]]]):
    edges.append((up, down, {'label' : dep_way}))
    down.up_level_nodes.add(up)
    down.up_level_dep_ways[up] = dep_way
    up.down_level_nodes.add(down)
    up.down_level_dep_ways[down] = dep_way


def find_deep_dict(data : Dict, up_keys : Tuple, sub_type : str, result : Dict[Tuple, List[str]]):
    if up_keys and isinstance(up_keys, str):
        up_keys = (up_keys,)
    if isinstance(data, dict):
        if sub_type in data:
            dep_way = (*up_keys, sub_type) if up_keys else (sub_type,)
            if isinstance(data[sub_type], list):
                result[dep_way] = data[sub_type]
            else:
                result[dep_way] = [data[sub_type]]
        else:
            for key in data:
                dep_way = (*up_keys, key) if up_keys else (key,)
                find_deep_dict(data[key], dep_way, sub_type, result)


def check_down_genrule_depends(up : SectionNode, down : SectionNode) -> (bool, str):
    if re.search(r"genrule\Z", down.section['section_type']):
        sub_types = [ "srcs" ]
        for st in sub_types:
            result : Dict[Tuple, List[str]] = {}
            find_deep_dict(up.section, (), st, result)
            for dep_way, values in result.items():
                if check_name_matching(values, down.section):
                    return True, '#'.join(dep_way)

    return False, None

def check_binaries(up : SectionNode, down : SectionNode) -> (bool, str):
    result : Dict[Tuple, List[str]] = {}
    sub_types = ("binaries", "static_libs", "shared_libs", "header_libs", "export_shared_lib_headers", "whole_static_libs")
    for st in sub_types:
        find_deep_dict(up.section, (), st, result)
        for dep_way, values in result.items():
            if check_name_matching(values, down.section):
                return True, '#'.join(dep_way)

    return False, None

def check_section_name_matching(name : str, section : Section) -> bool:
    if section['section_name'] == name:
        return True
    elif (re.search(r"^:\w+", name) and
        section['section_name'] == name[1:]):
        return True
    else:
        return False

def check_name_matching(values : List[str], section : Section) -> bool:
    for name in values:
        if (re.search(r"^:\w+", name) and
            section['section_name'] == name[1:]):
            return True
        elif section['section_name'] == name:
            return True
    return False

def check_if_subtype_matching(up : SectionNode, down : SectionNode, sub_type : str) -> (bool, str):
    if sub_type in up.section:
        values = up.section[sub_type] if isinstance(up.section[sub_type], list) else [ up.section[sub_type] ]
        if check_name_matching(values, down.section):
            return True, sub_type

    return False, None


def depends_on_impl(up : SectionNode, down : SectionNode) -> (bool, str):
    if (up == down or
        up.section['section_type'] in excluded_section_types or
        down.section['section_type'] in excluded_section_types or
        up.section['section_name'] == down.section['section_name'] or
        is_defaults_module(up) or is_defaults_module(down) or
        check_target_matching(up, down) is False or
        check_if_cc_bin_unmatching(up, down) is True or
        check_host_supported_matching(up, down) is False):
        # if check_if_debug_nodes(up, down):
        #     if check_host_supported_matching(up, down) is False:
        #         raise LookupError
        #     elif check_if_cc_bin_unmatching(up, down) is True:
        #         raise LookupError
        #     elif check_target_matching(up, down) is False:
        #         raise LookupError
        #     else:
        #         raise LookupError
        return False, None

    # success, dep_way = check_if_subtype_matching(up, down, 'deps')
    # if success:
    #     return True, dep_way

    success, dep_way = check_if_subtype_matching(up, down, 'data')
    if success:
        return True, dep_way

    genrule, success, sub_type = check_up_genrule_depends(up, down)
    if genrule:
        return success, sub_type

    success, dep_way = check_down_genrule_depends(up, down)
    if success:
        return True, dep_way

    success, dep_way = check_binaries(up, down)
    if success:
        return True, dep_way

    success, sub_type = check_if_subtype_matching(up, down, 'pluginFor')
    if success:
        return True, sub_type

    section_suffixed_names = get_backend_suffixed_names(down.section)

    for sub_type, values in up.section.items():
        if sub_type in excluded_sub_types:
            continue

        elif isinstance(values, str) and down.section['section_name'] == values:
            if (sub_type == 'certificate' and
                down.section['section_type'] != 'android_app_certificate'):
                continue
            else:
                return True, sub_type
        elif isinstance(values, list) and down.section['section_name'] in values:
            return True, sub_type

        for name in section_suffixed_names:
            if isinstance(values, str) and name == values:
                return True, sub_type
            elif isinstance(values, list) and name in values:
                return True, sub_type

        if sub_type in COLON_PREFIX_ENABLED_SUB_TYPES:
            if (isinstance(values, str) and
                (values == ":" + down.section['section_name'])):
                return True, sub_type
            elif (isinstance(values, list) and
                  (":" + down.section['section_name']) in values):
                return True, sub_type

        if (sub_type == 'multilib' and isinstance(values, dict)):
            multi = [ 'both', 'first' ]
            for m in multi:
                if (m in values and
                    isinstance(values[m], dict) and
                    'binaries' in values[m]):
                    if (isinstance(values[m]['binaries'], list) and
                        down.section['section_name'] in values[m]['binaries']):
                        return True, 'multilib' + m + 'binaries'
                    elif down.section['section_name'] == values[m]['binaries']:
                        return True, 'multilib' + m + 'binaries'

    # if check_if_debug_nodes(up, down):
    #     raise LookupError

    return False, None

def depends_on(up : Section, down : Section) -> (bool, bool, str):
    success, section_type = depends_on_impl(up, down)
    if success is True:
        return True, True, section_type
    else:
        success, section_type = depends_on_impl(down, up)
        if success is True:
            return True, False, section_type
        else:
            return False, False, None


all_module_types = [
    "javadoc", "display_go_defaults_sm7250", "rust_test", "dex_import", "aidl_mapping", "versioned_ndk_headers", "llvm_defaults", "libart_static_cc_defaults", "cc_benchmark_host", "generate_mojom_downgraded_files", "prebuilt_apis", "llndk_headers", "sanitizer_status_library_shared", "art_debug_defaults", "generate_mojom_pickles", "rust_binary_host", "aidl_interfaces_metadata", "target_fs_config_gen_filegroup", "hidl_interfaces_metadata", "art_apex_test_host", "generate_mojom_srcjar", "sh_test_host", "rust_defaults", "display_go_defaults", "robolectric_build_props", "llvm_host_defaults", "force_build_llvm_components_defaults", "generate_mojom_headers", "hiddenapi_flags", "art_apex_test", "clang_builtin_headers", "generate_mojom_srcs", "llvm_prebuilt_library_static", "art_apex", "kernel_headers", "bootstrap_go_binary", "sdk", "rust_prebuilt_dylib", "art_global_defaults", "java_host_for_device", "soong_config_module_type", "droidstubs_host", "global_compat_config", "libart_cc_defaults", "tradefed_java_library_host", "droiddoc_host", "droiddoc", "ca_certificates_host", "ca_certificates", "java_genrule_host", "override_apex", "java_system_modules", "llvm_darwin_filegroup", "apex_vndk", "llvm_host_prebuilt_library_shared", "android_app_import", "module_exports", "rust_library_dylib", "service_contexts", "wayland_protocol_codegen", "platform_compat_config", "art_cc_library_static", "hwservice_contexts", "file_contexts", "prebuilt_usr_share", "vndk_libraries_txt", "fluoride_defaults", "property_contexts", "toolchain_library", "droiddoc_exported_dir", "libclang_rt_llndk_library", "rust_proc_macro", "stubs_defaults", "python_test", "bpf", "vintf_compatibility_matrix", "tradefed_binary_host", "sysprop_library", "java_device_for_host", "clang_tblgen", "java_sdk_library_import", "prebuilt_etc_host", "android_test_import", "llvm_tblgen", "genrule_defaults", "art_cc_test_library", "cc_library_host_shared", "hidl_package_root", "droidstubs", "apex_test", "se_filegroup", "rust_test_host", "kernel_config", "java_test_helper_library", "gensrcs", "sh_binary_host", "se_cil_compat_map", "art_cc_defaults", "apex_defaults", "java_binary", "cc_object", "llndk_library", "libclang_rt_prebuilt_library_shared", "java_plugin", "rust_library_rlib", "android_robolectric_test", "ndk_library", "xsd_config", "java_sdk_library", "art_cc_test", "cc_prebuilt_library_shared", "java_test", "java_genrule", "sh_binary", "cc_genrule", "python_defaults", "ndk_headers", "blueprint_go_binary", "phony", "python_library", "cc_prebuilt_binary", "art_cc_binary", "prebuilt_apex", "libclang_rt_prebuilt_library_static", "python_test_host", "rust_library_host_rlib", "apex_key", "cc_benchmark", "runtime_resource_overlay", "python_library_host", "android_app_certificate", "sh_test", "java_binary_host", "prebuilt_usr_share_host", "aidl_interface", "cc_library_host_static", "cc_fuzz", "cc_test_host", "ndk_prebuilt_object", "apex", "art_cc_library", "java_defaults", "python_binary_host", "bootstrap_go_package", "java_import_host", "java_import", "java_library_static", "android_library_import", "java_library_host", "cc_binary_host", "prebuilt_etc", "hidl_interface", "cc_library_headers", "android_library", "prebuilt_font", "android_app", "java_test_host", "java_library", "cc_test_library", "cc_library", "vts_config", "genrule", "cc_library_shared", "cc_binary", "android_test", "cc_defaults", "filegroup", "android_test_helper_app", "cc_library_static", "cc_test", "vndk_prebuilt_shared"
    ]
